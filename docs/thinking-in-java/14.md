---
title: 第十四章-类型信息/反射
date: 2020-12-16
---

**RTTI**（Run-Time Type Identification）运行时类型识别；运行时类型识别是必要的：继承和多态提供了一种编写通用代码的能力，但是经常也会出现一些特殊情况，需要对某些类型特判；



这个词一直是 C++ 中的概念，至于Java中出现RTTI的说法则是源于《Thinking in Java》一书，其作用是在运行时识别一个对象的类型和类的信息。这里分两种：

- 编译期的：也叫传统的”RRTI”，它假定我们在编译期已知道了所有类型(在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型，如new对象时该类必须已定义好)，
- 另外一种是运行期的：利用反射机制它允许我们在运行时发现和使用类型的信息。



在Java中用来表示运行时类型信息的对应类就是Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。

实际上在Java中每个类都有一个Class对象，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象并且这个Class对象会被保存在同名.class文件里；

当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。注意，我们定义的一个类，无论创建多少个实例对象，在JVM中都只有一个Class对象与其对应，即：在内存中每个类有且只有一个相对应的Class对象；



类加载器子系统实际上是一条加载器链；



到这我们也就可以得出以下几点信息：

- Class类也是类的一种，其创建后的对象称作class对象；
- 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中；
- 每个通过关键字class标识的类，无论创建多少个实例对象，在内存中有且只有一个与之对应的Class对象来描述其类型信息；
- Class类只有私有构造函数，因此对应Class对象只能有JVM创建和加载；
- Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要；

注：Class对象是后面反射的基础，反射包中的很多类都需要和Class对象一起配合使用。



Class.forName()接受的参数为全限定类名的字符串，返回一个Class对象的引用，通常我们会忽略它的返回值，只是为了它的副作用：如果类还没有加载就加载它；如果找不到指定的类，就会抛出ClassNotFoundException；





## 反射的概念

Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。

![image-20201217110418307](https://raw.githubusercontent.com/MilesGO517/images/master/20201217110419.png)

### 动态语言和静态语言

**动态语言**

是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以 被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运 行时代码可以根据某些条件改变自身结构。

流行的动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。

**静态语言**

与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。



Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动 态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。 Java的动态性让编程的时候更加灵活！

### Java反射机制提供的功能

- 在运行时判断任意一个对象所属的类 
- 在运行时构造任意一个类的对象 
- 在运行时判断任意一个类所具有的成员变量和方法 
- 在运行时获取泛型信息 
- 在运行时调用任意一个对象的成员变量和方法 
- 在运行时处理注解 
- 生成动态代理

### 反射相关的主要API

- java.lang.Class:代表一个类 
- java.lang.reflect.Method:代表类的方法 
- java.lang.reflect.Field:代表类的成员变量 
- java.lang.reflect.Constructor:代表类的构造器



## 反射的简单使用

```java
public class Person {
    private String name;
    public int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private Person(String name) {
        this.name = name;
    }

    public Person() {
        System.out.println("Person()");
    }

    public void show(){
        System.out.println("你好，我是一个人");
    }

    private String showNation(String nation){
        System.out.println("我的国籍是：" + nation);
        return nation;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

public class ReflectionTest {
    @Test
    public void test2() throws Exception{
        Class clazz = Person.class;
        //1.通过反射，创建Person类的对象
        Constructor cons = clazz.getConstructor(String.class,int.class);
        Object obj = cons.newInstance("Tom", 12);
        Person p = (Person) obj;
        System.out.println(p.toString());
        //2.通过反射，调用对象指定的属性、方法
        //调用属性
        Field age = clazz.getDeclaredField("age");
        age.set(p,10);
        System.out.println(p.toString());

        //调用方法
        Method show = clazz.getDeclaredMethod("show");
        show.invoke(p);

        System.out.println("*******************************");

        //通过反射，可以调用Person类的私有结构的。比如：私有的构造器、方法、属性
        //调用私有的构造器
        Constructor cons1 = clazz.getDeclaredConstructor(String.class);
        cons1.setAccessible(true);
        Person p1 = (Person) cons1.newInstance("Jerry");
        System.out.println(p1);

        //调用私有的属性
        Field name = clazz.getDeclaredField("name");
        name.setAccessible(true);
        name.set(p1,"HanMeimei");
        System.out.println(p1);

        //调用私有的方法
        Method showNation = clazz.getDeclaredMethod("showNation", String.class);
        showNation.setAccessible(true);
        String nation = (String) showNation.invoke(p1,"中国");//相当于String nation = p1.showNation("中国")
        System.out.println(nation);
    }
}
```



## Class类

在Object类中定义了以下的方法，此方法将被所有子类继承，返回值的类型是一个Class类

 ● public final Class getClass()



- Class本身也是一个类 
- Class 对象只能由系统建立对象 
- 一个加载的类在 JVM 中只会有一个Class实例 
- 一个Class对象对应的是一个加载到JVM中的一个.class文件 
- 每个类的实例都会记得自己是由哪个 Class 实例所生成 
- 通过Class可以完整地得到一个类中的所有被加载的结构 
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class对象







### Class类的常用方法

![image-20201217112835885](https://raw.githubusercontent.com/MilesGO517/images/master/20201217112836.png)

关于java.lang.Class类的理解
1.类的加载过程：
程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。
接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件
加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此
运行时类，就作为Class的一个实例。

2.换句话说，Class的实例就对应着一个运行时类。
3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式
来获取此运行时类。



### 获取Class实例的方式

```java
    @Test
    public void test3() throws ClassNotFoundException {
        //方式一：调用运行时类的属性：.class
        Class clazz1 = Person.class;
        System.out.println(clazz1);
        //方式二：通过运行时类的对象,调用getClass()
        Person p1 = new Person();
        Class clazz2 = p1.getClass();
        System.out.println(clazz2);

        //方式三：调用Class的静态方法：forName(String classPath)
        Class clazz3 = Class.forName("com.atguigu.java.Person");
//        clazz3 = Class.forName("java.lang.String");
        System.out.println(clazz3);

        System.out.println(clazz1 == clazz2);
        System.out.println(clazz1 == clazz3);

        //方式四：使用类的加载器：ClassLoader  (了解)
        ClassLoader classLoader = ReflectionTest.class.getClassLoader();
        Class clazz4 = classLoader.loadClass("com.atguigu.java.Person");
        System.out.println(clazz4);

        System.out.println(clazz1 == clazz4);

    }
```

方式一：类字面常量，更简单、安全，编译时就会受到检查，因此不像Class.forName需要放置在try语句块中；

使用这种方式，不会自动地**初始化**该Class对象。初始化被延迟到了对**静态方法（包括构造器）**或者**非常数静态域**进行首次引用时才执行；

如下代码，对Initable的staticFinal的调用不会触发初始化，因为是常数静态域：

```java
class Initable {
  static final int staticFinal = 47;
  static final int staticFinal2 =
    ClassInitialization.rand.nextInt(1000);
  static {
    System.out.println("Initializing Initable");
  }
}

class Initable2 {
  static int staticNonFinal = 147;
  static {
    System.out.println("Initializing Initable2");
  }
}

class Initable3 {
  static int staticNonFinal = 74;
  static {
    System.out.println("Initializing Initable3");
  }
}

public class ClassInitialization {
  public static Random rand = new Random(47);
  public static void main(String[] args) throws Exception {
    Class initable = Initable.class; // 没有触发初始化
    System.out.println("After creating Initable ref");
    // Does not trigger initialization:
    System.out.println(Initable.staticFinal); // 没有触发初始化
    // Does trigger initialization:
    System.out.println(Initable.staticFinal2); // 触发
    // Does trigger initialization:
    System.out.println(Initable2.staticNonFinal); // 触发
    Class initable3 = Class.forName("com.milesgo.study.java.typeinfo.Initable3"); // 触发
    System.out.println("After creating Initable3 ref");
    System.out.println(Initable3.staticNonFinal);
  }
} /* Output:
After creating Initable ref
47
Initializing Initable
258
Initializing Initable2
147
Initializing Initable3
After creating Initable3 ref
74
*///:~
```







### Class实例可以对应哪些结构

```java
    @Test
    public void test4(){
        Class c1 = Object.class;
        Class c2 = Comparable.class;
        Class c3 = String[].class;
        Class c4 = int[][].class;
        Class c5 = ElementType.class;
        Class c6 = Override.class;
        Class c7 = int.class;
        Class c8 = void.class;
        Class c9 = Class.class;

        int[] a = new int[10];
        int[] b = new int[100];
        Class c10 = a.getClass();
        Class c11 = b.getClass();
        // 只要数组的元素类型与维度一样，就是同一个Class
        System.out.println(c10 == c11);

    }
```

1. class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类
2. interface：接口
3. []：数组
4. enum：枚举
5. annotation：注解@interface
6. primitive type：基本数据类型
7. void

对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段是一个引用，指向对应的基本数据类型的Class对象，如下所示：

| 基本数据类型.class | 包装器类.TYPE  |
| ------------------ | -------------- |
| boolean.class      | Boolean.TYPE   |
| char.class         | Character.TYPE |
| byte.class         | Byte.TYPE      |
| short.class        | Short.TYPE     |
| int.class          | Integer.TYPE   |
| long.class         | Long.TYPE      |
| float.class        | Float.TYPE     |
| double.class       | Double.TYPE    |
| void.class         | Void.TYPE      |



### 使用泛型的Class引用

通过使用泛型语法，可以让编译器强制执行额外的类型检查；如果泛型是确切类型而不是通配符指定的范围，则newInstance将返回该对象的确切类型；

```java
// 使用通配符
public class WildcardClassReferences {
  public static void main(String[] args) {
    Class<?> intClass = int.class;
    intClass = double.class;
  }
} ///:~


// 通配符结合extends限定范围
public class BoundedClassReferences {
  public static void main(String[] args) {
    Class<? extends Number> bounded = int.class;
    bounded = double.class;
    bounded = Number.class;
    // Or anything else derived from Number.
  }
} ///:~


class CountedInteger {
  private static long counter;
  private final long id = counter++;
  public String toString() { return Long.toString(id); }
}

public class FilledList<T> {
  private Class<T> type;
  public FilledList(Class<T> type) { this.type = type; }	
  public List<T> create(int nElements) {
    List<T> result = new ArrayList<T>();
    try {
      for(int i = 0; i < nElements; i++)
        result.add(type.newInstance());
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
    return result;
  }
  public static void main(String[] args) {
    FilledList<CountedInteger> fl =
      new FilledList<CountedInteger>(CountedInteger.class);
    System.out.println(fl.create(15));
  }
} /* Output:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
*///:~

public class GenericToyTest {
  public static void main(String[] args) throws Exception {
    Class<FancyToy> ftClass = FancyToy.class;
    // Produces exact type:
    FancyToy fancyToy = ftClass.newInstance();
    Class<? super FancyToy> up = ftClass.getSuperclass();
    // This won't compile:
    // Class<Toy> up2 = ftClass.getSuperclass();  // 这种写法不能通过编译
    // Only produces Object:
    Object obj = up.newInstance();  // 返回的是一个Object
  }
} ///:~
```



### Class的cast方法转型

挺少用的

```java
class Building {}

class House extends Building {}

public class ClassCasts {
  public static void main(String[] args) {
    Building b = new House();
    Class<House> houseType = House.class;
    House h = houseType.cast(b);
    h = (House)b; // ... or just do this.
  }
} ///:~
```



### Class的asSubclass方法转型

`public <U> Class<? extends U> asSubclass(Class<U> clazz)  `

这是java.lang.Class中的一个方法，作用是将调用这个方法的class对象转换成由clazz参数所表示的class对象的某个子类。



Class.forName()的返回类型是Class<?>，但这显然太宽泛了；假设我们需要List.class类型的class对象，但我们传递给Class.forName的参数是未知的（可能是"java.lang.String"，也可能是"java.util.ArrayList"），这时我们就可以用到asSubclass()这个方法了，如下：

```
Class.forName("xxx.xxx.xxx").asSubclass(List.class).newInstance();  
```

当xxx.xxx.xxx是List的子类时，正常执行，当不是List的子类时，抛出ClassCastException，这时我们可以做些别的处理；

如果我们查看Class.asSubclass()在JDK中的中的引用的话，会发现这种用法有很多。



## 类的加载与ClassLoader的理解

### 类的加载过程

![image-20201217235629200](https://raw.githubusercontent.com/MilesGO517/images/master/20201217235630.png)

加载：这个加载的过程需要类加载器参与。该步骤将查找字节码文件，并从这些字节码中创建一个Class对象。将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。

链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 

- 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题；
- 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 （为静态域分配存储空间）
- 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。（如果必需的话，将解析这个类创建的对其他类的所有引用）

初始化： 

- 执行类构造器`<cinit>()`方法的过程。类构造器`<cinit>()`方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 (执行静态初始化器和静态初始化块)
- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 
- 虚拟机会保证一个类的`<cinit>()`方法在多线程环境中被正确加锁和同步。



```
public class ClassLoadingTest {
    public static void main(String[] args) {
    System.out.println(A.m);
    }   
}
class A {
    static {
        m = 300;
    }
    static int m = 100;
}
//第二步：链接结束后m=0
//第三步：初始化后，m的值由<clinit>()方法执行决定
// 这个A的类构造器<clinit>()方法由类变量的赋值和静态代码块中的语句按照顺序合并
产生，类似于
// <clinit>(){
    // m = 300;
    // m = 100;
// }
```

## 什么时候会发生类初始化

类的主动引用（一定会发生类的初始化） 

- 当虚拟机启动，先初始化main方法所在的类 
- new一个类的对象 
- 调用类的静态成员（除了final常量）和静态方法 
- 使用java.lang.reflect包的方法对类进行反射调用 
- 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 

类的被动引用（不会发生类的初始化） 

- 当访问一个静态域时，只有真正声明这个域的类才会被初始化 
- 当通过子类引用父类的静态变量，不会导致子类初始化 
- 通过数组定义类引用，不会触发此类的初始化 
- 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）



```
public class ClassLoadingTest {
    public static void main(String[] args) {
        // 主动引用：一定会导致A和Father的初始化
        // A a = new A();
        // System.out.println(A.m);
        // Class.forName("com.atguigu.java2.A");
        // 被动引用
        A[] array = new A[5];//不会导致A和Father的
        初始化
        // System.out.println(A.b);//只会初始化
        Father
        // System.out.println(A.M);//不会导致A和
        Father的初始化
    }
    static {
        System.out.println("main所在的类");
    }
}

class Father {
    static int b = 2;
    static {
        System.out.println("父类被加载");
    }
}
class A extends Father {
    static {
        System.out.println("子类被加载");
        m = 300;
    }
    static int m = 100;
    static final int M = 1;
}
```



### 类加载器的作用

![image-20201218010830908](https://raw.githubusercontent.com/MilesGO517/images/master/20201218010831.png)

类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。 

类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。

类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的 类的加载器。

![image-20201218003951667](https://raw.githubusercontent.com/MilesGO517/images/master/20201218003952.png)

```java
    @Test
    public void test1() throws ClassNotFoundException {
        //1.获取一个系统类加载器
        //对于自定义类，使用系统类加载器进行加载
        ClassLoader classloader = ClassLoader.getSystemClassLoader();
//        ClassLoader classloader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classloader); // sun.misc.Launcher$AppClassLoader@18b4aac2

        //2.获取系统类加载器的父类加载器，即扩展类加载器
        classloader = classloader.getParent();
        System.out.println(classloader); // sun.misc.Launcher$ExtClassLoader@27716f4

        //3.获取扩展类加载器的父类加载器，即引导类加载器，获取结果为null
        //引导类加载器主要负责加载java的核心类库，无法加载自定义类。
        classloader = classloader.getParent();
        System.out.println(classloader); // null，引导类加载器无法获取

        //4.测试当前类由哪个类加载器进行加载
        classloader = Class.forName("exer2.ClassloaderDemo").getClassLoader();
        System.out.println(classloader);

        //5.测试JDK提供的Object类由哪个类加载器加载
        classloader = Class.forName("java.lang.Object").getClassLoader();
//        classloader = Object.class.getClassLoader();
        System.out.println(classloader);

        //*6.关于类加载器的一个主要方法：getResourceAsStream(String str):
        // 获取类路径下的指定文件的输入流
        InputStream in = null;
        in = this.getClass().getClassLoader().getResourceAsStream("jdbc.properties");
        System.out.println(in);

        Properties props = new Properties();
        props.load(in);
        System.out.println(props.getProperty("username"));
    }
```



## 通过Class创建运行时类的对象

```java
@Test
public void test1() throws IllegalAccessException, InstantiationException {

    Class<Person> clazz = Person.class;
    /*
    newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。

    要想此方法正常的创建运行时类的对象，要求：
    1.运行时类必须提供空参的构造器
    2.空参的构造器的访问权限得够。通常，设置为public。


    在javabean中要求提供一个public的空参构造器。原因：
    1.便于通过反射，创建运行时类的对象
    2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器

     */
    Person obj = clazz.newInstance();
    System.out.println(obj);

}
```

创建类的对象：调用Class对象的newInstance()

方法 要 求： 1）类必须有一个无参数的构造器。 2）类的构造器的访问权限需要足够。

难道没有无参的构造器就不能创建对象了吗？ 不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 

步骤如下： 

1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类 型的构造器 

2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 

3）通过Constructor实例化对象。

```
//1.根据全类名获取对应的Class对象
String name = “atguigu.java.Person";
Class clazz = null;
clazz = Class.forName(name);
//2.调用指定参数结构的构造器，生成Constructor的实例
Constructor con = clazz.getConstructor(String.class,Integer.class);
//3.通过Constructor的实例创建对应类的对象，并初始化类属性
Person p2 = (Person) con.newInstance("Peter",20);
System.out.println(p2);
```



### 体会反射的动态性

```java
    //体会反射的动态性
    @Test
    public void test2(){
        for(int i = 0;i < 100;i++){
            int num = new Random().nextInt(3);//0,1,2
            String classPath = "";
            switch(num){
                case 0:
                    classPath = "java.util.Date";
                    break;
                case 1:
                    classPath = "java.lang.Object";
                    break;
                case 2:
                    classPath = "com.atguigu.java.Person";
                    break;
            }
            try {
                Object obj = getInstance(classPath);
                System.out.println(obj);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /*
    创建一个指定类的对象。
    classPath:指定类的全类名
     */
    public Object getInstance(String classPath) throws Exception {
       Class clazz =  Class.forName(classPath);
       return clazz.newInstance();
    }
```



## 获取运行时类的完整结构

### 准备一个丰富结构的运行时类

```java
@MyAnnotation(value="hi")
public class Person extends Creature<String> implements Comparable<String>,MyInterface{

    private String name;
    int age;
    public int id;

    public Person(){}

    @MyAnnotation(value="abc")
    private Person(String name){
        this.name = name;
    }

     Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    @MyAnnotation
    private String show(String nation){
        System.out.println("我的国籍是：" + nation);
        return nation;
    }

    public String display(String interests,int age) throws NullPointerException,ClassCastException{
        return interests + age;
    }


    @Override
    public void info() {
        System.out.println("我是一个人");
    }

    @Override
    public int compareTo(String o) {
        return 0;
    }

    private static void showDesc(){
        System.out.println("我是一个可爱的人");
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                '}';
    }
}

public class Creature<T> implements Serializable {
    private char gender;
    public double weight;

    private void breath(){
        System.out.println("生物呼吸");
    }

    public void eat(){
        System.out.println("生物吃东西");
    }

}

@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "hello";

}

public interface MyInterface {
    void info();
}

```

### 通过反射获取结构的API

1.实现的全部接口 

public Class[] getInterfaces() 确定此对象所表示的类或接口实现的接口。



2.所继承的父类 

public Class getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。



3.全部的构造器 

public Constructor[] getConstructors() 返回此 Class 对象所表示的类的所有public构造方法。 

public Constructor[] getDeclaredConstructors() 返回此 Class 对象表示的类声明的所有构造方法。



 Constructor类中： 

取得修饰符: public int getModifiers(); 

取得方法名称: public String getName(); 

取得参数的类型：public Class[] getParameterTypes();



4.全部的方法 

public Method[] getDeclaredMethods() 返回此Class对象所表示的类或接口的全部方法 

public Method[] getMethods() 返回此Class对象所表示的类或接口的public的方法



Method类中： 

public Class getReturnType()取得全部的返回值 

public Class[] getParameterTypes()取得全部的参数 

public int getModifiers()取得修饰符 

public Class[] getExceptionTypes()取得异常信息



5.全部的Field 

public Field[] getFields() 返回此Class对象所表示的类或接口的public的Field。 

public Field[] getDeclaredFields() 返回此Class对象所表示的类或接口的全部Field



Field方法中： 

public int getModifiers() 以整数形式返回此Field的修饰符 

public Class getType() 得到Field的属性类型 

public String getName() 返回Field的名称。



6.Annotation相关 

get Annotation(Class annotationClass) 

getDeclaredAnnotations() 



7.泛型相关 

获取父类泛型类型：Type getGenericSuperclass() 

泛型类型：ParameterizedType 

获取实际的泛型类型参数数组：getActualTypeArguments() 



8.类所在的包 

Package getPackage() 



### 通过反射获取运行时类的属性

```java
public class FieldTest {

    @Test
    public void test1(){
        Class clazz = Person.class;

        //获取属性结构
        //getFields():获取当前运行时类及其父类中声明为public访问权限的属性
        Field[] fields = clazz.getFields();
        for(Field f : fields){
            System.out.println(f);
        }
        System.out.println();

        //getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）
        Field[] declaredFields = clazz.getDeclaredFields();
        for(Field f : declaredFields){
            System.out.println(f);
        }
    }

    //权限修饰符  数据类型 变量名
    @Test
    public void test2(){
        Class clazz = Person.class;
        Field[] declaredFields = clazz.getDeclaredFields();
        for(Field f : declaredFields){
            //1.权限修饰符
            int modifier = f.getModifiers();
            System.out.print(Modifier.toString(modifier) + "\t");

            //2.数据类型
            Class type = f.getType();
            System.out.print(type.getName() + "\t");

            //3.变量名
            String fName = f.getName();
            System.out.print(fName);

            System.out.println();
        }
    }
}
```

### 通过反射获取运行时类的方法

```java
public class MethodTest {

    @Test
    public void test1(){
        Class clazz = Person.class;

        //getMethods():获取当前运行时类及其所有父类中声明为public权限的方法
        Method[] methods = clazz.getMethods();
        for(Method m : methods){
            System.out.println(m);
        }
        System.out.println();
        //getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for(Method m : declaredMethods){
            System.out.println(m);
        }
    }

    /*
    @Xxxx
    权限修饰符  返回值类型  方法名(参数类型1 形参名1,...) throws XxxException{}
     */
    @Test
    public void test2(){
        Class clazz = Person.class;
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for(Method m : declaredMethods){
            System.out.println("-----------------");
            //1.获取方法声明的注解(RUNTIME)
            Annotation[] annos = m.getAnnotations();
            for(Annotation a : annos){
                System.out.println(a);
            }

            //2.权限修饰符
            System.out.print(Modifier.toString(m.getModifiers()) + "\t");

            //3.返回值类型
            System.out.print(m.getReturnType().getName() + "\t");

            //4.方法名
            System.out.print(m.getName());
            System.out.print("(");
            //5.形参列表
            Class[] parameterTypes = m.getParameterTypes();
            if(!(parameterTypes == null && parameterTypes.length == 0)){
                for(int i = 0;i < parameterTypes.length;i++){

                    if(i == parameterTypes.length - 1){
                        System.out.print(parameterTypes[i].getName() + " args_" + i);
                        break;
                    }

                    System.out.print(parameterTypes[i].getName() + " args_" + i + ",");
                }
            }

            System.out.print(")");

            //6.抛出的异常
            Class[] exceptionTypes = m.getExceptionTypes();
            if(exceptionTypes.length > 0){
                System.out.print("throws ");
                for(int i = 0;i < exceptionTypes.length;i++){
                    if(i == exceptionTypes.length - 1){
                        System.out.print(exceptionTypes[i].getName());
                        break;
                    }
                    System.out.print(exceptionTypes[i].getName() + ",");
                }
            }
            System.out.println();
        }
    }
}
```

### 通过反射获取其它结构

```java
public class OtherTest {
    /*获取构造器结构*/
    @Test
    public void test1(){
        Class clazz = Person.class;
        //getConstructors():获取当前运行时类中声明为public的构造器
        Constructor[] constructors = clazz.getConstructors();
        for(Constructor c : constructors){
            System.out.println(c);
        }

        System.out.println();
        //getDeclaredConstructors():获取当前运行时类中声明的所有的构造器
        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();
        for(Constructor c : declaredConstructors){
            System.out.println(c);
        }
    }

    /*获取运行时类的父类*/
    @Test
    public void test2(){
        Class clazz = Person.class;

        Class superclass = clazz.getSuperclass();
        System.out.println(superclass);
    }

    /*获取运行时类的带泛型的父类*/
    @Test
    public void test3(){
        Class clazz = Person.class;

        Type genericSuperclass = clazz.getGenericSuperclass();
        System.out.println(genericSuperclass);
    }

    /*获取运行时类的带泛型的父类的泛型*/
    @Test
    public void test4(){
        Class clazz = Person.class;

        Type genericSuperclass = clazz.getGenericSuperclass();
        ParameterizedType paramType = (ParameterizedType) genericSuperclass;
        //获取泛型类型
        Type[] actualTypeArguments = paramType.getActualTypeArguments();
//        System.out.println(actualTypeArguments[0].getTypeName());
        System.out.println(((Class)actualTypeArguments[0]).getName());
    }

    /*获取运行时类实现的接口*/
    @Test
    public void test5(){
        Class clazz = Person.class;

        Class[] interfaces = clazz.getInterfaces();
        for(Class c : interfaces){
            System.out.println(c);
        }

        System.out.println();
        //获取运行时类的父类实现的接口
        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();
        for(Class c : interfaces1){
            System.out.println(c);
        }
    }
    /*获取运行时类所在的包*/
    @Test
    public void test6(){
        Class clazz = Person.class;

        Package pack = clazz.getPackage();
        System.out.println(pack);
    }

    /*获取运行时类声明的注解*/
    @Test
    public void test7(){
        Class clazz = Person.class;

        Annotation[] annotations = clazz.getAnnotations();
        for(Annotation annos : annotations){
            System.out.println(annos);
        }
    }
}
```



## 调用运行时类的指定结构

### 调用指定方法

通过反射，调用类中的方法，通过Method类完成。步骤：

1.通过Class类的getMethod(String name,Class…parameterTypes)方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。 

2.之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中 传递要设置的obj对象的参数信息。

![image-20201218030604291](https://raw.githubusercontent.com/MilesGO517/images/master/20201218030605.png)



Object invoke(Object obj, Object … args)

说明： 

1.Object 对应原方法的返回值，若原方法无返回值，此时返回null 

2.若原方法若为静态方法，此时形参Object obj可为null 

3.若原方法形参列表为空，则Object[] args为null 

4.若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法

### 调用指定属性

在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和 get()方法就可以完成设置和取得属性内容的操作。 

public Field getField(String name) 返回此Class对象表示的类或接口的指定的 public的Field。 

public Field getDeclaredField(String name)返回此Class对象表示的类或接口的 指定的Field。

在Field中： 

public Object get(Object obj) 取得指定对象obj上此Field的属性内容 

public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容

### 关于setAccessible方法的使用

Method和Field、Constructor对象都有setAccessible()方法。 

setAccessible启动和禁用访问安全检查的开关。 

参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 

​	提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被 调用，那么请设置为true。 

​	使得原本无法访问的私有成员也可以访问 

参数值为false则指示反射的对象应该实施Java语言访问检查



```java
/**
 * 调用运行时类中指定的结构：属性、方法、构造器
 *
 * @author shkstart
 * @create 2019 下午 4:46
 */
public class ReflectionTest {

    @Test
    public void testField() throws Exception {
        Class clazz = Person.class;

        //创建运行时类的对象
        Person p = (Person) clazz.newInstance();
        //获取指定的属性：要求运行时类中属性声明为public
        //通常不采用此方法
        Field id = clazz.getField("id");
        /*设置当前属性的值
        set():参数1：指明设置哪个对象的属性   参数2：将此属性值设置为多少*/
        id.set(p,1001);
        /*获取当前属性的值
        get():参数1：获取哪个对象的当前属性值*/
        int pId = (int) id.get(p);
        System.out.println(pId);
    }

    /*如何操作运行时类中的指定的属性 -- 需要掌握*/
    @Test
    public void testField1() throws Exception {
        Class clazz = Person.class;

        //创建运行时类的对象
        Person p = (Person) clazz.newInstance();

        //1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性
        Field name = clazz.getDeclaredField("name");

        //2.保证当前属性是可访问的
        name.setAccessible(true);
        //3.获取、设置指定对象的此属性值
        name.set(p,"Tom");

        System.out.println(name.get(p));
    }

    /*如何操作运行时类中的指定的方法 -- 需要掌握*/
    @Test
    public void testMethod() throws Exception {

        Class clazz = Person.class;

        //创建运行时类的对象
        Person p = (Person) clazz.newInstance();

        /*1.获取指定的某个方法
        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表
         */
        Method show = clazz.getDeclaredMethod("show", String.class);
        //2.保证当前方法是可访问的
        show.setAccessible(true);

        /*3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参
        invoke()的返回值即为对应类中调用的方法的返回值。
         */
        Object returnValue = show.invoke(p,"CHN"); //String nation = p.show("CHN");
        System.out.println(returnValue);

        System.out.println("*************如何调用静态方法*****************");

        // private static void showDesc()

        Method showDesc = clazz.getDeclaredMethod("showDesc");
        showDesc.setAccessible(true);
        //如果调用的运行时类中的方法没有返回值，则此invoke()返回null
//        Object returnVal = showDesc.invoke(null);
        Object returnVal = showDesc.invoke(Person.class);
        System.out.println(returnVal);//null

    }

    /*如何调用运行时类中的指定的构造器*/
    @Test
    public void testConstructor() throws Exception {
        Class clazz = Person.class;

        //private Person(String name)
        /*1.获取指定的构造器getDeclaredConstructor():参数：指明构造器的参数列表*/

        Constructor constructor = clazz.getDeclaredConstructor(String.class);

        //2.保证此构造器是可访问的
        constructor.setAccessible(true);

        //3.调用此构造器创建运行时类的对象
        Person per = (Person) constructor.newInstance("Tom");
        System.out.println(per);
    }
}
```



## 类型转换前先做检查





## 反射的应用：动态代理

